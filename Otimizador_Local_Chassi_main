#Versão 1.1 - Tentativa de implementar paralelização para a criação da população e dos individuos. Ajustar o max_workers de acordo com a capacidade de seu processador

import numpy as np
from copy import deepcopy
from concurrent.futures import ProcessPoolExecutor, as_completed
import itertools
import traceback
from Estrutura_Tipada import Estrutura
import matplotlib.pyplot as plt
import os
import datetime
import time
max_workers = max(1, os.cpu_count() - 2)

class ChassisDEOptimizer:
    
    """
    Otimizador de geometria de chassi tubular usando Differential Evolution (DE).

    Atributos:
    - base_nodes: np.ndarray, coordenadas iniciais dos nós de um lado (x>=0).
    - base_connections: list of tuple, pares de índices representando arestas base.
    - mandatory_indices: índices de nós que têm deslocamento limitado a radius_mand.
    - pop_size, F, CR, max_gens: parâmetros do DE (tamanho pop., taxa de mutação, crossover, gerações).
    - radius_mand, radius_opt: raios máximos de deslocamento para nós mandatórios e opcionais.
    - tipos_tubos: lista de strings com perfis de tubo permitidos.
    """

    def __init__(
        self,
        base_nodes: np.ndarray,
        base_connections: list,
        mandatory_indices: list,
        pop_size: int = 50,
        F: float = 0.5,
        CR: float = 0.9,
        max_generations: int = 200,
        radius_mand: float = 0.05,
        radius_opt: float = 0.10,
        use_parallel: bool = True
    ):
        """
        Inicializa o otimizador.

        Entradas:
        - base_nodes: array (n,3) de floats.
        - base_connections: lista de tuplas (i,j).
        - mandatory_indices: lista de inteiros.
        - pop_size, F, CR, max_generations: parâmetros DE.
        - radius_mand, radius_opt: floats definindo limites de deslocamento.
        - use_parallel: bool, se True permitir paralelismo. (não utilizado neste código)

        Retorno:
        - Nenhum (configura atributos internos).
        """
        self.base_nodes = base_nodes.copy()
        self.n = base_nodes.shape[0]
        self.n_tubes = len(base_connections)
        self.base_connections = base_connections
        self.mandatory = set(mandatory_indices)
        self.radius_mand = radius_mand
        self.radius_opt = radius_opt

        self.tipos_tubos = ['Tubo A', 'Tubo B', 'Tubo C', 'Tubo D']

        # DE parameters
        self.pop_size = pop_size
        self.F = F
        self.CR = CR
        self.max_gens = max_generations

        # genotype dimension: coords + tube_vars
        self.dim_coords = 3 * self.n
        self.dim_tubes = self.n_tubes
        self.dim = self.dim_coords + self.dim_tubes

    def reflect_nodes(self, nodes: np.ndarray) -> np.ndarray:
        """
        Espelha coordenadas de nós no plano x=0.

        Entrada:
        - nodes: array (m,3) de floats.
        Saída:
        - mirrored: array (m,3) onde mirrored[:,0] = -nodes[:,0].
        """
        mirrored = nodes.copy()
        mirrored[:, 0] *= -1
        return mirrored

    def enforce_bounds(self, coords: np.ndarray) -> np.ndarray:
        """
        Aplica limites de deslocamento e arredonda as coordenadas.

        Entrada:
        - coords: array (n,3) de floats (proposta de deslocamento).
        Saída:
        - adjusted: array (n,3) de floats, cada deslocamento limitado a radius_mand ou radius_opt
          e arredondado para 3 casas decimais.
        """
        adjusted = coords.copy()
        for i in range(self.n):
            orig = self.base_nodes[i]
            delta = coords[i] - orig
            dist = np.linalg.norm(delta)
            r_max = self.radius_mand if i in self.mandatory else self.radius_opt
            if dist > r_max:
                adjusted[i] = orig + delta / dist * r_max
        # Arredonda para 3 casas decimais para estabilidade da evolução
        adjusted = np.round(adjusted, 3)
        return adjusted

    def decode_individual(self, x: np.ndarray):
        """
        Converte um vetor genotípico em nós completos e lista de elementos.

        Entrada:
        - x: array (dim_coords+dim_tubes,) de floats.
        Saída:
        - nodes_full: array (N,3) de floats com nós de ambos os lados.
        - elements: lista de tuplas (i, j, perfil), com índices nos nodes_full.

        Processos:
        1. Extrai coords e tube_vars do vetor x.
        2. Aplica enforce_bounds às coords.
        3. Para nós com base x≈0, inclui apenas um nó (central).
           Para outros, inclui coord e seu espelho.
        4. Usa mapeamento para gerar conexões simétricas com tipo de tubo.
        """
        # Separa coords e tube_vars
        coords = x[:self.dim_coords].reshape((self.n, 3))
        tube_vars = x[self.dim_coords:]

        # Aplica bounds
        coords = self.enforce_bounds(coords)

        # Monta os nós completos com mapeamento para índices
        full_nodes = []
        mapping = {}
        for i, coord in enumerate(coords):
            # central: x original == 0
            if np.isclose(self.base_nodes[i, 0], 0.0):
                idx = len(full_nodes)
                full_nodes.append(coord)
                mapping[i] = [idx]
            else:
                # lateral: coordenada e seu espelho
                idx1 = len(full_nodes)
                full_nodes.append(coord)
                mirrored = coord.copy()
                mirrored[0] *= -1
                idx2 = len(full_nodes)
                full_nodes.append(mirrored)
                mapping[i] = [idx1, idx2]

        nodes_full = np.array(full_nodes)

        # Monta conexões com tipo de tubo simétrico
        elements = []
        for idx_conn, (i, j) in enumerate(self.base_connections):
            # determina perfil a partir de tube_vars
            tval = tube_vars[idx_conn]
            t_int = int(np.clip(np.floor(tval), 0, len(self.tipos_tubos) - 1))
            perfil = self.tipos_tubos[t_int]
            # combina índices conforme mapeamento
            ids_i = mapping[i]
            ids_j = mapping[j]
            # se ambos centrais
            if len(ids_i) == 1 and len(ids_j) == 1:
                elements.append((ids_i[0], ids_j[0], perfil))
            # se ambos laterais, conecta pares correspondentes
            elif len(ids_i) == 2 and len(ids_j) == 2:
                elements.append((ids_i[0], ids_j[0], perfil))
                elements.append((ids_i[1], ids_j[1], perfil))
            # se um central e outro lateral, conecta central a ambos
            else:
                # identifica qual é central
                if len(ids_i) == 1:
                    cent = ids_i[0]; lats = ids_j
                else:
                    cent = ids_j[0]; lats = ids_i
                for lat in lats:
                    elements.append((cent, lat, perfil))

        return nodes_full, elements

    def validate_min_distance(self, coords, min_dist=0.07):
        """
        Verifica se todas as distâncias entre pares de nós são maiores ou iguais
        a uma distância mínima especificada.

        Parâmetros:
        - coords (np.ndarray): Array de forma (N, 3) contendo as coordenadas dos nós.
        - min_dist (float, opcional): Distância mínima permitida entre quaisquer dois nós (default = 0.05).

        Retorno:
        - bool: True se todos os pares de nós respeitam a distância mínima, False caso contrário.
        """
        min_d2 = min_dist**2
        n = coords.shape[0]
        for i in range(n):
            diffs = coords[i+1:] - coords[i]
            if np.any(np.sum(diffs * diffs, axis=1) < min_d2):
                return False
        return True
    
    def initialize_individual(self) -> np.ndarray:
        """
        Gera um indivíduo válido.

        Saída:
        - x: array (dim,) de floats, contendo coords arredondadas e tube_vars iniciais.
        """
        while True:
            # Gera coords aleatórias
            deltas = np.random.normal(size=(self.n, 3))
            norms = np.linalg.norm(deltas, axis=1, keepdims=True)
            deltas = deltas / norms * (np.random.rand(self.n,1) ** (1/3) * self.radius_opt)
            coords = self.base_nodes + deltas
            coords = self.enforce_bounds(coords)
            # tube_vars iniciais aleatórios entre [0,4)
            tube_vars = np.random.uniform(0, len(self.tipos_tubos), size=(self.n_tubes,))
            x = np.concatenate([coords.reshape(-1), tube_vars])
            nodes, _ = self.decode_individual(x)

            if self.validate_min_distance(nodes):
                #print("Individuo valido" ,end="\r")
                return x

    def initialize_population(self):
        """
        Constrói a população inicial de forma diversa e avalia em paralelo.

        Saída:
        - pop: array (pop_size, dim) de indivíduos.
        - fitness: array (pop_size,) de floats.
        """
        # 1) Gera candidatos iniciais garantindo diversidade mínima
        pop = np.zeros((self.pop_size, self.dim))
        cand = []
        seen = set()
        while len(cand) < self.pop_size:
            indiv = self.initialize_individual()
            # Hash aproximado (arredonda a 3 casas) para evitar clones
            key = tuple(np.round(indiv, 3))
            if key in seen:
                continue
            seen.add(key)
            cand.append(indiv)

        # 2) Avaliação paralela de fitness
        fitness = np.zeros(self.pop_size)
        with ProcessPoolExecutor(max_workers=max_workers) as executor:
            results = list(executor.map(self.evaluate, cand))
        for i, (f_i, _, _, _) in enumerate(results):
            pop[i] = cand[i]
            fitness[i] = f_i

        return pop, fitness

    def evaluate(self, x: np.ndarray) -> float:
        """
        Avalia o custo de um indivíduo.

        Entrada:
        - x: array (dim,) de floats.
        Saída:
        - float, valor de penalidade (fitness).

        Processo:
        1. Decodifica para nodes e elements.
        2. Checa distância mínima.
        3. Monta e analisa pela classe Estrutura (FEA).
        4. Calcula penalidade via penalidade_chassi.
        """
        try:
            nodes, elements = self.decode_individual(x)
            if not self.validate_min_distance(nodes):
                return float('inf')
            estrutura = Estrutura(elements, nodes)
            estrutura.matrizes_global()
            fixed = list(range(6))
            Fg = np.zeros(estrutura.num_dofs)
            Fg[1+0*6] = 300
            Fg[1+2*6] = 300
            disp = estrutura.static_analysis(Fg, fixed)
            stresses = estrutura.compute_stress(estrutura.compute_strain(disp))
            von = estrutura.compute_von_mises(stresses)
            massa = estrutura.mass()
            *_, KT, KF, _, _ = estrutura.shape_fun()
            return (penalidade_chassi(KT, KF, massa, von),massa,KT,KF)
        except Exception:
            traceback.print_exc()
            return 1e9, 1e9, 0.0, 0.0

    def mutate_and_crossover(self, idx, pop):
        """
        Gera um novo indivíduo por DE/rand/1 + crossover binomial.

        Entradas:
        - idx: índice do indivíduo-alvo.
        - pop: array (pop_size, dim) população atual.
        Saída:
        - u: array (dim,) candidato filho (ou x_i se inválido).
        """
        idxs = list(range(self.pop_size)); idxs.remove(idx)
        a, b, c = np.random.choice(idxs, 3, replace=False)
        x_i = pop[idx]
        x_a, x_b, x_c = pop[a], pop[b], pop[c]
        # mutação DE/rand/1
        v = x_a + self.F * (x_b - x_c)
        # crossover binomial
        j_rand = np.random.randint(self.dim)
        u = np.array([v[j] if np.random.rand()<self.CR or j==j_rand else x_i[j]
                      for j in range(self.dim)])
        # aplica bounds às coords
        coords = self.enforce_bounds(u[:self.dim_coords].reshape(self.n,3)).reshape(-1)
        tube_vars = np.clip(u[self.dim_coords:], 0, len(self.tipos_tubos)-1e-3)
        u = np.concatenate([coords, tube_vars])
        # valida distância
        if self.validate_min_distance(self.decode_individual(u)[0]):
            return u
        return x_i

    def optimize(self):
        """
        Executa o loop principal de otimização, com avaliação paralela.

        Retorna:
        - best_solution: tupla (nodes, elements)
        - best_cost: float
        - best_mass, best_KT, best_KF: floats
        - history: dict com listas de métricas por geração
        """
        print("Otimização Iniciada")
        pop, fit = self.initialize_population()

        # Histórico e controle de convergência
        history = {
            'best_fit': [], 'avg_fit': [], 'std_dev': [],
            'best_mass': [], 'best_KT': [], 'best_KF': []
        }
        convergence_count = 0
        convergence_threshold = 3
        start_time = time.time()
        for gen in range(1, self.max_gens + 1):
            # 1) Gera candidatos
            cand_pop = [self.mutate_and_crossover(i, pop) for i in range(self.pop_size)]

            # 2) Avaliação paralela
            new_pop = pop.copy()
            new_fit = fit.copy()
            new_mass = np.full(self.pop_size, np.nan)
            new_KT   = np.full(self.pop_size, np.nan)
            new_KF   = np.full(self.pop_size, np.nan)

            with ProcessPoolExecutor(max_workers=max_workers) as executor:
                futures = {executor.submit(self.evaluate, cand_pop[i]): i for i in range(self.pop_size)}
                for fut in as_completed(futures):
                    i = futures[fut]
                    try:
                        f_u, m_u, kt_u, kf_u = fut.result()
                    except Exception:
                        traceback.print_exc()
                        f_u, m_u, kt_u, kf_u = float('inf'), float('nan'), float('nan'), float('nan')

                    new_mass[i], new_KT[i], new_KF[i] = m_u, kt_u, kf_u

                    # 3) Seleção
                    if f_u <= fit[i]:
                        new_pop[i] = cand_pop[i]
                        new_fit[i] = f_u
                    else:
                        # Marca para reavaliação posterior
                        new_mass[i], new_KT[i], new_KF[i] = float('nan'), float('nan'), float('nan')

            # Atualiza pop e fit
            pop, fit = new_pop, new_fit

            # Preenche métricas faltantes reavaliando
            for i in range(self.pop_size):
                if np.isnan(new_mass[i]):  # Verifica tanto None quanto NaN
                    try:
                        _, m_i, kt_i, kf_i = self.evaluate(pop[i])
                        new_mass[i], new_KT[i], new_KF[i] = m_i, kt_i, kf_i
                    except Exception:
                        new_mass[i], new_KT[i], new_KF[i] = float('inf'), float('inf'), float('inf')

            # Garantia para o melhor indivíduo
            best_idx = np.argmin(fit)
            if np.isnan(new_mass[best_idx]) or np.isnan(new_KT[best_idx]) or np.isnan(new_KF[best_idx]):
                try:
                    _, m_best, kt_best, kf_best = self.evaluate(pop[best_idx])
                    new_mass[best_idx], new_KT[best_idx], new_KF[best_idx] = m_best, kt_best, kf_best
                except Exception:
                    new_mass[best_idx], new_KT[best_idx], new_KF[best_idx] = -1, -1, -1

            # Estatísticas
            best_fit = fit[best_idx]
            avg_fit  = fit.mean()
            std_dev  = np.mean(np.std(pop, axis=0))

            history['best_fit'].append(best_fit)
            history['avg_fit'].append(avg_fit)
            history['std_dev'].append(std_dev)
            history['best_mass'].append(new_mass[best_idx])
            history['best_KT'].append(new_KT[best_idx])
            history['best_KF'].append(new_KF[best_idx])

            # Logging e convergência
            if std_dev < 0.02:
                convergence_count += 1
                status = f"Convergindo (Std={std_dev:.4f}, Count={convergence_count})"
            else:
                convergence_count = 0
                status = f"Best={best_fit:.4e} Std={std_dev:.4f}"
            print(f"Gen {gen}/{self.max_gens} — {status}", end='\r')

            if convergence_count >= convergence_threshold:
                print(f"\nConvergência após {gen} gerações (Std={std_dev:.4f})")
                break
        duration = time.time() - start_time            
        # Pós-processamento
        best_idx = np.argmin(fit)
        best_solution = self.decode_individual(pop[best_idx])
        best_cost = fit[best_idx]
        best_mass, best_KT, best_KF = (
            history['best_mass'][-1], history['best_KT'][-1], history['best_KF'][-1]
        )
        return best_solution, best_cost, best_mass, best_KT, best_KF, history, duration
    
    def plotar(self, individuo, save_path=None):
        """
        Plota a geometria do chassi evoluído em 3D.

        Entrada:
        - individuo: tupla (nodes, elements)
        - save_path: caminho opcional para salvar a imagem

        Saída:
        - exibe o plot e/ou salva a imagem se o caminho for fornecido.
        """
        nodes, elements = individuo
        fig = plt.figure(figsize=(10, 6))
        ax = fig.add_subplot(111, projection='3d')

        num_nodes = len(nodes)
        elements_valid = [(i, j, t) for i, j, t in elements if 0 <= i < num_nodes and 0 <= j < num_nodes]

        xs, ys, zs = zip(*nodes)
        ax.scatter(ys, xs, zs, s=25, c='black')
        for i, j, t in elements_valid:
            ni, nj = nodes[i], nodes[j]
            ax.plot([ni[1], nj[1]], [ni[0], nj[0]], [ni[2], nj[2]], 'b-')

        ax.set_xlabel('Y')
        ax.set_ylabel('X')
        ax.set_zlabel('Z')
        ax.set_box_aspect([3, 1, 2])
        plt.title("Chassi Evoluído")

        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches='tight')
            print(f"Visualização 3D salva em: {save_path}")

        plt.show()

    def plot_metrics(self, history, save_path=None, show=True):
        """
        Gera gráfico de evolução das métricas: massa, rigidez torcional e flexional.

        Entradas:
        - history: dict com as listas 'best_mass', 'best_KT', 'best_KF'.
        - save_path: caminho opcional para salvar o PNG.
        - show: bool, se True exibe o plot.
        """
        plt.figure(figsize=(10, 6))
        gens = range(len(history['best_mass']))
        
        # Configura eixo primário (massa)
        ax1 = plt.gca()
        ax1.plot(gens, history['best_mass'], 'b-', linewidth=2, label='Massa (kg)')
        ax1.set_xlabel('Geração')
        ax1.set_ylabel('Massa (kg)', color='b')
        ax1.tick_params(axis='y', labelcolor='b')
        
        # Configura eixo secundário (rigidezes)
        ax2 = ax1.twinx()
        ax2.plot(gens, history['best_KT'], 'r-', linewidth=2, label='Rigidez Torcional (KT)')
        ax2.plot(gens, history['best_KF'], 'g-', linewidth=2, label='Rigidez Flexional (KF)')
        ax2.set_ylabel('Rigidez (N·m/rad ou N/m)', color='r')
        ax2.tick_params(axis='y', labelcolor='r')
        
        plt.title('Evolução das Métricas do Melhor Indivíduo')
        
        # Unificar legendas
        lines1, labels1 = ax1.get_legend_handles_labels()
        lines2, labels2 = ax2.get_legend_handles_labels()
        ax1.legend(lines1 + lines2, labels1 + labels2, loc='best')
        
        plt.grid(True)
        plt.tight_layout()
        
        if save_path:
            plt.savefig(save_path)
            print(f"Gráfico de métricas salvo em: {save_path}")
        
        if show:
            plt.show()
        else:
            plt.close()

    def plot_convergence(self, history, save_path=None, show=True):
        """
        Gera gráfico de convergência: fitness vs geração e std_dev.

        Entradas:
        - history: dict com 'best_fit', 'avg_fit', 'std_dev'.
        - save_path: caminho opcional para salvar o PNG.
        - show: bool, se True exibe o plot.
        """
        plt.figure(figsize=(10, 6))
        
        # Gráfico duplo eixo Y
        ax1 = plt.gca()
        ax2 = ax1.twinx()
        
        # Curva de fitness
        ax1.plot(history['best_fit'], 'b-', linewidth=2, label='Melhor Fitness')
        ax1.plot(history['avg_fit'], 'b--', alpha=0.7, label='Fitness Médio')
        ax1.set_ylabel('Fitness', color='b')
        ax1.tick_params(axis='y', labelcolor='b')
        ax1.set_yscale('log')
        
        # Curva de desvio padrão
        ax2.plot(history['std_dev'], 'r-', linewidth=2, label='Desvio Padrão')
        ax2.axhline(y=0.2, color='g', linestyle='--', label='Limite Convergência')
        ax2.set_ylabel('Desvio Padrão', color='r')
        ax2.tick_params(axis='y', labelcolor='r')
        
        plt.title('Progresso da Otimização')
        plt.xlabel('Geração')
        plt.grid(True)
        
        # Unificar legendas
        lines1, labels1 = ax1.get_legend_handles_labels()
        lines2, labels2 = ax2.get_legend_handles_labels()
        ax1.legend(lines1 + lines2, labels1 + labels2, loc='upper right')
        
        plt.tight_layout()
        
        if save_path:
            plt.savefig(save_path)
            print(f"Gráfico de convergência salvo em: {save_path}")
        
        if show:
            plt.show()
        else:
            plt.close()

    def plot_tradeoff(self, history, axises=('mass','KT'), save_path=None, show=True):
        x_key = {'mass':'best_mass','KT':'best_KT','KF':'best_KF'}[axises[0]]
        y_key = {'mass':'best_mass','KT':'best_KT','KF':'best_KF'}[axises[1]]
        x, y = history[x_key], history[y_key]
        plt.figure(figsize=(8,6))
        sc = plt.scatter(x, y, c=range(len(x)), cmap='viridis', s=50)
        plt.colorbar(sc, label='Geração')
        plt.xlabel(axises[0].upper())
        plt.ylabel(axises[1].upper())
        plt.title(f"Trade-off: {axises[0]} × {axises[1]}")
        plt.grid(True)
        if save_path: plt.savefig(save_path, dpi=300)
        if show: plt.show()
        else: plt.close()

    def plot_fitness_vs_metric(self, history, metric='mass', save_path=None, show=True):
        mkey = f"best_{metric}"
        x, y = history[mkey], history['best_fit']
        plt.figure(figsize=(8,6))
        sc = plt.scatter(x, y, c=range(len(x)), cmap='plasma', s=40)
        plt.colorbar(sc, label='Geração')
        plt.xlabel(metric.upper())
        plt.ylabel('Fitness')
        plt.title(f"Fitness × {metric.upper()}")
        plt.grid(True)
        if save_path: plt.savefig(save_path, dpi=300)
        if show: plt.show()
        else: plt.close()

    def plot_all(self, history, results_dir, show=False):
        os.makedirs(results_dir, exist_ok=True)
        self.plot_convergence(history, save_path=os.path.join(results_dir,'convergencia.png'), show=show)
        self.plot_metrics(history, save_path=os.path.join(results_dir,'evolucao_metricas.png'), show=show)
        #self.plot_tradeoff(history, axises=('mass','KT'), save_path=os.path.join(results_dir,'tradeoff_mass_KT.png'), show=show)
        #self.plot_tradeoff(history, axises=('mass','KF'), save_path=os.path.join(results_dir,'tradeoff_mass_KF.png'), show=show)
        #self.plot_fitness_vs_metric(history,'mass', save_path=os.path.join(results_dir,'fitness_vs_mass.png'), show=show)
        #self.plot_fitness_vs_metric(history,'KT',   save_path=os.path.join(results_dir,'fitness_vs_KT.png'), show=show)
        #self.plot_fitness_vs_metric(history,'KF',   save_path=os.path.join(results_dir,'fitness_vs_KF.png'), show=show)
        print(f"Todos os gráficos salvos em: {results_dir}")

    def save_solution(self, nodes, elements, file_path, fitness=None, mass=None, KT=None, KF=None, duration=None):
        """
        Salva relatório completo em TXT, incluindo duração e valores do melhor indivíduo.
        """
        with open(file_path, 'w') as f:
            f.write("SOLUÇÃO FINAL DO CHASSI\n")
            f.write("="*60 + "\n\n")
            if duration is not None:
                hrs, rem = divmod(duration, 3600)
                mins, secs = divmod(rem, 60)
                f.write(f"Duração da Otimização: {int(hrs)}h {int(mins)}m {secs:.1f}s\n")
            if fitness is not None:
                f.write(f"Melhor Fitness: {fitness:.6e}\n")
            if mass is not None:
                f.write(f"Massa: {mass:.3f} kg\n")
            if KT is not None and KF is not None:
                f.write(f"Rigidez Torcional (KT): {KT:.3e} N·m/rad\n")
                f.write(f"Rigidez Flexional (KF): {KF:.3e} N/m\n")
            f.write("\nNÓS (X, Y, Z):\n")
            for i, node in enumerate(nodes):
                f.write(f"{i:3d}: {node[0]:6.3f}, {node[1]:6.3f}, {node[2]:6.3f}\n")
            f.write("\nELEMENTOS (Conexões):\n")
            for i, (ni, nj, tp) in enumerate(elements):
                f.write(f"{i:3d}: Nó {ni} - Nó {nj} | Perfil: {tp}\n")
        print(f"Relatório completo salvo em: {file_path}")

    def print_solution(self, nodes, elements):
        """
        Imprime no console nós e elementos formatados.

        Entradas:
        - nodes: array (N,3).
        - elements: lista de tuplas.
        """
        print("\n" + "="*50)
        print("SOLUÇÃO FINAL DO CHASSI")
        print("="*50)
        
        # Imprime nós
        print("\nNÓS:")
        print("Índice | Coordenada X | Coordenada Y | Coordenada Z")
        print("-"*50)
        for i, node in enumerate(nodes):
            print(f"{i:6d} | {node[0]:11.6f} | {node[1]:11.6f} | {node[2]:11.6f}")
        
        # Imprime elementos
        print("\n\nELEMENTOS (CONEXÕES):")
        print("Índice | Nó Inicial | Nó Final | Tipo de Tubo")
        print("-"*50)
        for i, elem in enumerate(elements):
            print(f"{i:6d} | {elem[0]:10d} | {elem[1]:9d} | {elem[2]}")   

def penalidade_chassi(KT, KF, massa, tensoes):
    """
    Calcula penalidade total do chassi.

    Entradas:
    - KT, KF: floats de rigidezes.
    - massa: float.
    - tensoes: array de floats.
    Saída:
    - penalidade_total: float.
    """

    # Limites e parâmetros
    KT_min = 1e7          # Rigidez torcional mínima (N·m/rad)
    KF_min = 1e6          # Rigidez flexão mínima (N/m)
    massa_ideal = 23       # Massa alvo (kg)
    K_mola = 5e5           # Constante da mola do amortecedor (N/m)
    tensao_adm = 250e6     # Tensão admissível do material (Pa)
    alpha = 0.5            # Fator de sensibilidade exponencial
    beta = 10              # Fator de escala logarítmica
    
    penalidade_total = 0

    # 1. Rigidez Torcional (Função Exponencial)
    if KT < KT_min:
        deficit = (KT_min - KT) / KT_min
        # Penalidade cresce exponencialmente com o déficit
        penalidade_total += np.exp(alpha * deficit) - 1

    # 2. Rigidez em Flexão (Função Logarítmica)
    if KF < KF_min:
        deficit = (KF_min - KF) / KF_min
        # Penalidade logarítmica: suave para pequenas violações, forte para grandes
        penalidade_total += beta * np.log(1 + deficit)

    # 3. Massa (Função Híbrida)
    if massa > massa_ideal:
        excesso = (massa - massa_ideal) / massa_ideal
        # Combina resposta linear inicial com crescimento exponencial
        penalidade_total += excesso + np.exp(alpha * excesso) - 1

    # 4. Compatibilidade com Mola (Lógica Aprimorada)
    ratio_KT = K_mola / KT if KT > 0 else float('inf')
    ratio_KF = K_mola / KF if KF > 0 else float('inf')
    
    if ratio_KT > 25 or ratio_KF > 25:
        # Penalidade proporcional ao nível de incompatibilidade
        violacao = max(ratio_KT/25, ratio_KF/25) - 1
        penalidade_total += 100 * violacao**2

    # 5. Tensões (Abordagem Baseada em Risco)
    tensao_max = max(tensoes)
    if tensao_max > tensao_adm:
        # Penalidade exponencial para tensões acima do admissível
        excesso = (tensao_max - tensao_adm) / tensao_adm
        penalidade_total += np.exp(5 * excesso) - 1
    
    # Penalidade por distribuição desigual de tensões (logarítmica)
    razao_tensoes = np.ptp(tensoes) / np.mean(tensoes) if np.mean(tensoes) > 0 else 0
    penalidade_total += np.log(1 + razao_tensoes)

    return penalidade_total * 100  # Fator de escala global

if __name__ == "__main__":
    nodes = np.array([
    [0.32, 1.92, 0.0],    #0
    [0.32, 1.92, 0.48],   #1
    [0.32, 1.77, 0.21],   #2
    [0.32, 1.5, 0.03],    #3
    [0.28, 1.14, 0.03],   #4
    [0.32, 1.14, 0.09],   #5
    [0.32, 1.23, 0.36],   #6
    [0.28, 1.14, 0.70],   #7
    [0.32, 0.63, 0.54],   #8
    [0.32, 0.69, 0.24],   #9
    [0.32, 0.69, 0.0],    #10
    [0.32, 0.45, 0.21],   #11
    [0.28, 0.24, 0.09],   #12
    [0.16, 0.0, 0.21],    #13
    [0.16, 0.0, 0.09],    #14
    [0.16, 0.0, 0.42],    #15
    [0.28, 0.33, 0.66],   #16
    [0.28, 0.57, 1.2],    #17
    [0.0, 0.54, 1.35],    #18
    [0.00, 1.14, 0.75],   #19
    [0.00, 1.92, 0.0],    #20
    [0.00, 1.92, 0.48],   #21
    [0.00, 0.33, 0.66],   #22
    [0.00, 0.0, 0.21],    #23
    [0.00, 0.0, 0.09],    #24
    [0.00, 0.0, 0.42],    #25
])
    connections = [
    (0, 1), (0,2),(0,3),(1,7),(0,20),
    (1,6), (1,2),(0,3),(8,17),(3,6),
    (3,4), (4,5),(4,10),(1,21),(16,22),
    (2, 6), (2,3),(0,3),(5,6),(6,9),(6,10),
    (3,5),(6,7),(7,8),(5,10),(10,12),
    (8,9),(8,6),(9,10),(11,13),
    (10,11),(11,12),(11,9),
    (13, 14), (12,14),(13,15),
    (7,19),(15,16),(16,17),(8,16),
    (17,18),(11,16),(8,11),(11,15),
    (13,23),(14,24),(15,25),
]

    indices = [0,1,3,5,6,7,8,10,14,15,16,17,18,19,20,21,22,23,24,25]

        # Criar diretório para resultados
    timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    results_dir = f"resultados_otimizacao_{timestamp}"
    os.makedirs(results_dir, exist_ok=True)

    otimizador = ChassisDEOptimizer(
        base_nodes= nodes,
        base_connections = connections,
        mandatory_indices = indices,
        pop_size=150,
        F=0.6,
        CR=0.8,
        max_generations=200,
        )

    best_indiv, best_cost, best_mass, best_KT, best_KF, history,duration = otimizador.optimize()
    print(f"\nRESULTADOS FINAIS:")
    print(f"Melhor custo: {best_cost:.6e}")
    print(f"Massa: {best_mass:.2f} kg")
    print(f"Rigidez Torcional (KT): {best_KT:.2e} N·m/rad")
    print(f"Rigidez Flexional (KF): {best_KF:.2e} N/m")
    nodes_final, elements_final = best_indiv
    
    # 1. Imprimir solução no console
    otimizador.print_solution(nodes_final, elements_final)
    
    # 2. Salvar solução em arquivo TXT
    solution_path = os.path.join(results_dir, "solucao_final.txt")
    otimizador.save_solution(
        nodes_final, elements_final, solution_path,
        fitness=best_cost, mass=best_mass, KT=best_KT, KF=best_KF, duration=duration)
    
    # Geração de todos os gráficos de uma única vez
    otimizador.plot_all(history, results_dir, show=False)
    # visualização 3D final
    otimizador.plotar(best_indiv, save_path=os.path.join(results_dir,'visualizacao_3d.png'))
